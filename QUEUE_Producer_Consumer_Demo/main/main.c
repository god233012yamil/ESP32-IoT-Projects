/*
File: main.c
Project: queue_producer_consumer_demo

Purpose:
  Demonstrate a simple, functional producer-consumer design using a FreeRTOS
  queue on ESP32 with ESP-IDF.

What this demo shows:
  - Creating a FreeRTOS queue in app_main()
  - Producer task periodically sending structured messages
  - Consumer task receiving and logging messages
  - Basic timeout handling (send and receive)
  - Clean, beginner-friendly patterns

Build and flash (example):
  idf.py set-target esp32
  idf.py build flash monitor

Notes:
  - This project is intentionally minimal and uses esp_log for output.
*/

#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"

#include "esp_log.h"

/* ------------------------- Configuration ------------------------- */
#define DEMO_QUEUE_LENGTH          (8)
#define PRODUCER_PERIOD_MS         (1000)
#define PRODUCER_SEND_TIMEOUT_MS   (50)
#define CONSUMER_RECV_TIMEOUT_MS   (2000)

/* ------------------------- Types ------------------------- */

/**
 * message_t
 *
 * A small packet passed from the producer task to the consumer task.
 *
 * Fields:
 *  - seq: Monotonic sequence number generated by the producer.
 *  - tick: Current FreeRTOS tick count at the time of sending.
 *  - payload: Example payload data (can represent sensor reading, etc.).
 */
typedef struct {
    uint32_t seq;
    TickType_t tick;
    int32_t payload;
} message_t;

/* ------------------------- Globals ------------------------- */
static const char *TAG = "queue_demo";
static QueueHandle_t g_msg_queue = NULL;

/* ------------------------- Functions ------------------------- */

/**
 * make_message
 *
 * Create a message_t instance with a predictable payload pattern.
 *
 * Args:
 *  seq: Message sequence number.
 *
 * Returns:
 *  A fully initialized message_t.
 */
static message_t make_message(uint32_t seq)
{
    message_t msg = {0};
    msg.seq = seq;
    msg.tick = xTaskGetTickCount();

    /* Example payload:
       In real firmware, this could be an ADC sample, GPIO state, sensor value, etc. */
    msg.payload = (int32_t)(seq * 10);

    return msg;
}

/**
 * producer_task
 *
 * Producer task that periodically creates a message and sends it to the queue.
 * If the queue is full, it logs a warning and continues.
 *
 * Args:
 *  pvParameters: Unused.
 */
static void producer_task(void *pvParameters)
{
    (void)pvParameters;

    uint32_t seq = 0;

    while (1) {
        seq++;
        message_t msg = make_message(seq);

        BaseType_t ok = xQueueSend(
            g_msg_queue,
            &msg,
            pdMS_TO_TICKS(PRODUCER_SEND_TIMEOUT_MS)
        );

        if (ok == pdPASS) {
            ESP_LOGI(TAG, "Producer sent: seq=%" PRIu32 " payload=%" PRIi32 " tick=%" PRIu32,
                     msg.seq, msg.payload, (uint32_t)msg.tick);
        } else {
            ESP_LOGW(TAG, "Producer drop (queue full): seq=%" PRIu32, msg.seq);
        }

        vTaskDelay(pdMS_TO_TICKS(PRODUCER_PERIOD_MS));
    }
}

/**
 * consumer_task
 *
 * Consumer task that receives messages from the queue and processes them.
 * If no message arrives within the timeout, it logs a heartbeat message.
 *
 * Args:
 *  pvParameters: Unused.
 */
static void consumer_task(void *pvParameters)
{
    (void)pvParameters;

    message_t msg;

    while (1) {
        BaseType_t ok = xQueueReceive(
            g_msg_queue,
            &msg,
            pdMS_TO_TICKS(CONSUMER_RECV_TIMEOUT_MS)
        );

        if (ok == pdPASS) {
            ESP_LOGI(TAG, "Consumer got : seq=%" PRIu32 " payload=%" PRIi32 " age_ticks=%" PRIu32,
                     msg.seq,
                     msg.payload,
                     (uint32_t)(xTaskGetTickCount() - msg.tick));
        } else {
            ESP_LOGI(TAG, "Consumer waiting... (no messages within %d ms)", CONSUMER_RECV_TIMEOUT_MS);
        }
    }
}

/**
 * create_demo_queue
 *
 * Create the FreeRTOS queue used for producer-consumer messaging.
 *
 * Returns:
 *  true if queue was created successfully, false otherwise.
 */
static bool create_demo_queue(void)
{
    g_msg_queue = xQueueCreate(DEMO_QUEUE_LENGTH, sizeof(message_t));
    return (g_msg_queue != NULL);
}

/**
 * start_demo_tasks
 *
 * Create and start the producer and consumer tasks.
 *
 * Notes:
 *  - Stack sizes are conservative for a demo.
 *  - Priorities are set so the consumer can run promptly when messages arrive.
 */
static void start_demo_tasks(void)
{
    const uint32_t stack_words = 2048; /* words, not bytes, in ESP-IDF task creation */

    xTaskCreate(producer_task, "producer_task", stack_words, NULL, 5, NULL);
    xTaskCreate(consumer_task, "consumer_task", stack_words, NULL, 6, NULL);
}

/**
 * app_main
 *
 * ESP-IDF application entry point.
 * Creates a queue and starts the demo tasks.
 */
void app_main(void)
{
    ESP_LOGI(TAG, "Queue producer-consumer demo starting...");

    if (!create_demo_queue()) {
        ESP_LOGE(TAG, "Failed to create queue. Out of memory?");
        return;
    }

    ESP_LOGI(TAG, "Queue created: length=%d item_size=%u",
             DEMO_QUEUE_LENGTH, (unsigned)sizeof(message_t));

    start_demo_tasks();

    ESP_LOGI(TAG, "Tasks started. Monitor output via idf.py monitor.");
}
